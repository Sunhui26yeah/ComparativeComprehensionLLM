import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Random;
import java.util.Set;
import java.util.StringTokenizer;

public class Main {

    public static void main(String[] args) throws IOException {
        new Main().run();
    }

    StringTokenizer str = null;
    BufferedReader in;
    PrintWriter out;

    void run() throws IOException {
        in = new BufferedReader(new InputStreamReader(System.in));
        out = new PrintWriter(new OutputStreamWriter(System.out));
        solve();
        out.flush();
        out.close();
    }

    String nextString() throws IOException {
        return in.readLine();
    }

    String nextToken() throws IOException {
        if (str == null || !str.hasMoreElements()) {
            str = new StringTokenizer(nextString());
        }
        return str.nextToken();
    }

    int nextInt() throws IOException {
        return Integer.parseInt(nextToken());
    }

    long nextLong() throws IOException {
        return Long.parseLong(nextToken());
    }

    double nextDouble() throws IOException {
        return Double.parseDouble(nextToken());
    }

    class Point implements Comparable<Point> {
        int x;
        int y;

        @Override
        public int compareTo(Point p) {
            if (p.x > x)
                return -1;
            if (p.x < x)
                return 1;
            if (p.y > y)
                return -1;
            if (p.y < y)
                return 1;
            return 0;
        }
    }

    private double Rastoyanie(Point p[], int i, int l) {
        int xx = p[i].x - p[l].x;
        int yy = p[i].y - p[l].y;
        xx = xx * xx;
        yy = yy * yy;
        return Math.sqrt(xx + yy);
    }

    private boolean Na_odnoy_pramoy(Point p[], int i, int j, int l) {
        return (p[i].y - p[j].y) * p[l].x + (p[j].x - p[i].x) * p[l].y
                + (p[i].x * p[j].y - p[j].x * p[i].y) == 0;
    }

    boolean isPrime(long p) {
        int t = (int) (Math.sqrt(p) + 1);
        for (int i = 2; i < t; i++) {
            if (p % i == 0)
                return false;
        }
        return true;
    }

    void solve() throws IOException {
        int n = nextInt();
        List<List<Integer>> g = new ArrayList<List<Integer>>(n);
        for (int i = 0; i < n; i++) {
            g.add(new ArrayList<Integer>());
        }

        int k = nextInt();
        for (int i = 0; i < k; i++) {
            int x = nextInt() - 1;
            int y = nextInt() - 1;
            g.get(x).add(y);
            g.get(y).add(x);
        }

        List<List<Integer>> f = new ArrayList<List<Integer>>(n);
        for (int i = 0; i < n; i++) {
            f.add(new ArrayList<Integer>());
        }
        int m = nextInt();
        for (int i = 0; i < m; i++) {
            int x = nextInt() - 1;
            int y = nextInt() - 1;
            f.get(x).add(y);
            f.get(y).add(x);
        }

        boolean a[] = new boolean[n];
        for (int i = 0; i < n; i++) {
            a[i] = false;
        }
        int p[] = new int[n];
        for (int i = 0; i < n; i++) {
            p[i] = i;
        }
        for (int i = 0; i < n; i++) {
            for (int t : g.get(i)) {
                union(p, i, t);
            }
        }
        int h = 0;
        for (int i = 0; i < n; i++) {
            if (a[i])
                continue;
            int r = root(p, i);
            a[i] = true;
            int b = 0;
            if (C(f, p, r, n)) {
                for (int x = 0; x < n; x++) {
                    if (root(p, x) == r)
                        b++;
                }
            }
            if (b > h)
                h = b;
        }
        if (h == 0)
            h = 1;
        out.println(h);
    }

    private boolean C(List<List<Integer>> f, int[] p, int r, int n) {
        int a[] = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = 0;
        }
        for (int x = 0; x < n; x++) {
            if (root(p, x) == r)
                a[x] = 1;
        }
        for (int i = 0; i < n; i++) {
            if (root(p, i) == r)
                for (int t : f.get(i)) {
                    if (root(p, t) == r) {
                        return false;
                    }
                }
        }
        return true;
    }

    int root(int p[], int x) {
        if (p[x] == x)
            return x;
        return p[x] = root(p, p[x]);
    }

    boolean isUnion(int p[], int x, int y) {
        return root(p, x) == root(p, y);
    }

    Random rand = new Random();

    void union(int p[], int x, int y) {
        x = root(p, x);
        y = root(p, y);
        if (rand.nextBoolean()) {
            p[x] = y;
        } else {
            p[y] = x;
        }
    }
}