#include <bits/stdc++.h>
using namespace std;
template <typename T>
void println(const T &t) {
  cout << t << '\n';
}
template <typename T, typename... Args>
void println(const T &t, const Args &...rest) {
  cout << t << ' ';
  println(rest...);
}
template <typename T>
void print(const T &t) {
  cout << t << ' ';
}
template <typename T, typename... Args>
void print(const T &t, const Args &...rest) {
  cout << t;
  print(rest...);
}
template <class T>
void scan(T &t) {
  cin >> t;
}
template <class T, class... Args>
void scan(T &a, Args &...rest) {
  cin >> a;
  scan(rest...);
}
using ll = long long;
using vl = vector<ll>;
using vi = vector<int>;
using pii = pair<int, int>;
using vb = vector<bool>;
using vpii = vector<pii>;
auto bet = [](const ll x, const ll y, const ll i) { return x <= i && i <= y; };
template <typename T>
struct bit {
  vector<T> a;
  explicit bit(int n, int v = 0) {
    a.resize(n + 1);
    if (v != 0) {
      for (int i = 1; i <= n; ++i) a[i] = v;
    }
  }
  T sum(T x) {
    T res = 0;
    while (x) {
      res += a[x];
      x -= x & -x;
    }
    return res;
  }
  T sum(int l, int r) {
    if (l > r) return 0;
    return sum(r) - sum(l - 1);
  }
  void add(int x, T v) {
    while (x < a.size()) {
      a[x] += v;
      x += x & -x;
    }
  }
  void clear() { fill(a.begin(), a.end(), 0); }
};
vi get_prime(int n) {
  vi minp(n + 1), p;
  for (int i = 2; i <= n; i++) {
    if (!minp[i]) {
      minp[i] = i;
      p.push_back(i);
    }
    for (auto &x : p) {
      if (x <= minp[i] && x * i <= n)
        minp[x * i] = x;
      else
        break;
    }
  }
  return p;
}
const int mod = 998244353;
void add_mod(ll &x, const ll &y) {
  x += y;
  if (x >= mod) x -= mod;
}
void sub_mod(ll &x, const ll &y) {
  x -= y;
  if (x < 0) x += mod;
}
template <typename T>
using vv = vector<vector<T>>;
template <typename T1, typename T2 = T1>
using vp = vector<pair<T1, T2>>;
using vec = vector<ll>;
using mat = vector<vec>;
mat get_I(int n) {
  mat res(n, vec(n));
  for (int i = 0; i < n; i++) res[i][i] = 1;
  return res;
}
mat operator*(const mat &a, const mat &b) {
  mat c(a.size(), vec(b[0].size()));
  for (size_t i = 0; i < a.size(); i++) {
    for (size_t j = 0; j < a[0].size(); j++) {
      if (a[i][j]) {
        for (size_t k = 0; k < b[0].size(); k++) {
          add_mod(c[i][k], a[i][j] * b[j][k] % mod);
        }
      }
    }
  }
  return c;
}
vec operator*(const mat &a, const vec &b) {
  vec c(a.size());
  for (size_t i = 0; i < a.size(); i++) {
    for (size_t j = 0; j < a[0].size(); j++) {
      add_mod(c[i], a[i][j] * b[j] % mod);
    }
  }
  return c;
}
mat pow(mat a, ll n) {
  mat res(a.size(), vec(a[0].size()));
  for (size_t i = 0; i < a.size(); i++) {
    res[i][i] = 1;
  }
  while (n) {
    if (n & 1) {
      res = res * a;
    }
    a = a * a;
    n >>= 1;
  }
  return res;
}
const int N = 100005;
int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  int n, k;
  scan(n, k);
  vi d(n), lev(n);
  vi par(n);
  vv<int> g(n);
  for (int _ = 0, __ = (int)n - 1; _ < __; _++) {
    int u, v;
    scan(u, v);
    --u, --v;
    d[u]++, d[v]++;
    g[u].push_back(v), g[v].push_back(u);
  }
  int c3 = 0;
  for (int i = (0); i < (n); ++i) {
    if (d[i] == 2) {
      println("No");
      return 0;
    }
    c3 += d[i] == 3;
    if (c3 == 2) {
      println("No");
      return 0;
    }
  }
  queue<int> que;
  for (int i = (0); i < (n); ++i)
    if (d[i] == 1) {
      lev[i] = 1;
      for (auto &j : g[i]) {
        if (d[j] == 1) {
          ;
          {
            println("No");
            return 0;
          };
        }
        if (!lev[j]) {
          par[i] = j;
          lev[j] = lev[i] + 1;
          que.push(j);
        }
      }
    }
  while (que.size() > 1) {
    auto u = que.front();
    que.pop();
    bool flag = false;
    for (auto &v : g[u]) {
      if (lev[v]) {
        if (lev[v] == lev[u] + 1) {
          if (!flag)
            par[u] = v, flag = true;
          else {
            ;
            {
              println("No");
              return 0;
            }
          }
        } else if (lev[v] != lev[u] - 1) {
          ;
          {
            println("No");
            return 0;
          }
        }
      } else if (!flag) {
        flag = true;
        que.push(v);
        lev[v] = lev[u] + 1;
        par[v] = u;
      } else {
        ;
        {
          println("No");
          return 0;
        }
      }
    }
    if (!flag) {
      ;
      {
        println("No");
        return 0;
      }
    }
  };
  if (que.size() != 1) {
    println("No");
    return 0;
  };
  int u = que.front();
  ;
  if (lev[u] != k + 1 || c3 && d[u] != 3) {
    println("No");
    return 0;
  }
  println("Yes");
  return 0;
}